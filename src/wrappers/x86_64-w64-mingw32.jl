# Autogenerated wrapper script for libcxxwrap_julia_jll for x86_64-w64-mingw32
export libjlcxx_containers, libpointer_modification, libcxxwrap_julia_stl, libtypes, libhello, libinheritance, libcxxwrap_julia, libfunctions, libbasic_types, libextended, libparametric, libexcept

## Global variables
PATH = ""
LIBPATH = ""
LIBPATH_env = "PATH"

# Relative path to `libjlcxx_containers`
const libjlcxx_containers_splitpath = ["bin", "libjlcxx_containers.dll"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libjlcxx_containers_path = ""

# libjlcxx_containers-specific global declaration
# This will be filled out by __init__()
libjlcxx_containers_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libjlcxx_containers = "libjlcxx_containers.dll"


# Relative path to `libpointer_modification`
const libpointer_modification_splitpath = ["bin", "libpointer_modification.dll"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libpointer_modification_path = ""

# libpointer_modification-specific global declaration
# This will be filled out by __init__()
libpointer_modification_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libpointer_modification = "libpointer_modification.dll"


# Relative path to `libcxxwrap_julia_stl`
const libcxxwrap_julia_stl_splitpath = ["bin", "libcxxwrap_julia_stl.dll"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libcxxwrap_julia_stl_path = ""

# libcxxwrap_julia_stl-specific global declaration
# This will be filled out by __init__()
libcxxwrap_julia_stl_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libcxxwrap_julia_stl = "libcxxwrap_julia_stl.dll"


# Relative path to `libtypes`
const libtypes_splitpath = ["bin", "libtypes.dll"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libtypes_path = ""

# libtypes-specific global declaration
# This will be filled out by __init__()
libtypes_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libtypes = "libtypes.dll"


# Relative path to `libhello`
const libhello_splitpath = ["bin", "libhello.dll"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libhello_path = ""

# libhello-specific global declaration
# This will be filled out by __init__()
libhello_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libhello = "libhello.dll"


# Relative path to `libinheritance`
const libinheritance_splitpath = ["bin", "libinheritance.dll"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libinheritance_path = ""

# libinheritance-specific global declaration
# This will be filled out by __init__()
libinheritance_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libinheritance = "libinheritance.dll"


# Relative path to `libcxxwrap_julia`
const libcxxwrap_julia_splitpath = ["bin", "libcxxwrap_julia.dll"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libcxxwrap_julia_path = ""

# libcxxwrap_julia-specific global declaration
# This will be filled out by __init__()
libcxxwrap_julia_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libcxxwrap_julia = "libcxxwrap_julia.dll"


# Relative path to `libfunctions`
const libfunctions_splitpath = ["bin", "libfunctions.dll"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libfunctions_path = ""

# libfunctions-specific global declaration
# This will be filled out by __init__()
libfunctions_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libfunctions = "libfunctions.dll"


# Relative path to `libbasic_types`
const libbasic_types_splitpath = ["bin", "libbasic_types.dll"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libbasic_types_path = ""

# libbasic_types-specific global declaration
# This will be filled out by __init__()
libbasic_types_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libbasic_types = "libbasic_types.dll"


# Relative path to `libextended`
const libextended_splitpath = ["bin", "libextended.dll"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libextended_path = ""

# libextended-specific global declaration
# This will be filled out by __init__()
libextended_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libextended = "libextended.dll"


# Relative path to `libparametric`
const libparametric_splitpath = ["bin", "libparametric.dll"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libparametric_path = ""

# libparametric-specific global declaration
# This will be filled out by __init__()
libparametric_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libparametric = "libparametric.dll"


# Relative path to `libexcept`
const libexcept_splitpath = ["bin", "libexcept.dll"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libexcept_path = ""

# libexcept-specific global declaration
# This will be filled out by __init__()
libexcept_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libexcept = "libexcept.dll"


"""
Open all libraries
"""
function __init__()
    global artifact_dir = abspath(artifact"libcxxwrap_julia")

    # Initialize PATH and LIBPATH environment variable listings
    global PATH_list, LIBPATH_list
    # We first need to add to LIBPATH_list the libraries provided by Julia
    append!(LIBPATH_list, [Sys.BINDIR, joinpath(Sys.BINDIR, Base.LIBDIR, "julia"), joinpath(Sys.BINDIR, Base.LIBDIR)])
    global libjlcxx_containers_path = normpath(joinpath(artifact_dir, libjlcxx_containers_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libjlcxx_containers_handle = dlopen(libjlcxx_containers_path)
    push!(LIBPATH_list, dirname(libjlcxx_containers_path))

    global libpointer_modification_path = normpath(joinpath(artifact_dir, libpointer_modification_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libpointer_modification_handle = dlopen(libpointer_modification_path)
    push!(LIBPATH_list, dirname(libpointer_modification_path))

    global libcxxwrap_julia_stl_path = normpath(joinpath(artifact_dir, libcxxwrap_julia_stl_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libcxxwrap_julia_stl_handle = dlopen(libcxxwrap_julia_stl_path)
    push!(LIBPATH_list, dirname(libcxxwrap_julia_stl_path))

    global libtypes_path = normpath(joinpath(artifact_dir, libtypes_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libtypes_handle = dlopen(libtypes_path)
    push!(LIBPATH_list, dirname(libtypes_path))

    global libhello_path = normpath(joinpath(artifact_dir, libhello_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libhello_handle = dlopen(libhello_path)
    push!(LIBPATH_list, dirname(libhello_path))

    global libinheritance_path = normpath(joinpath(artifact_dir, libinheritance_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libinheritance_handle = dlopen(libinheritance_path)
    push!(LIBPATH_list, dirname(libinheritance_path))

    global libcxxwrap_julia_path = normpath(joinpath(artifact_dir, libcxxwrap_julia_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libcxxwrap_julia_handle = dlopen(libcxxwrap_julia_path)
    push!(LIBPATH_list, dirname(libcxxwrap_julia_path))

    global libfunctions_path = normpath(joinpath(artifact_dir, libfunctions_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libfunctions_handle = dlopen(libfunctions_path)
    push!(LIBPATH_list, dirname(libfunctions_path))

    global libbasic_types_path = normpath(joinpath(artifact_dir, libbasic_types_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libbasic_types_handle = dlopen(libbasic_types_path)
    push!(LIBPATH_list, dirname(libbasic_types_path))

    global libextended_path = normpath(joinpath(artifact_dir, libextended_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libextended_handle = dlopen(libextended_path)
    push!(LIBPATH_list, dirname(libextended_path))

    global libparametric_path = normpath(joinpath(artifact_dir, libparametric_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libparametric_handle = dlopen(libparametric_path)
    push!(LIBPATH_list, dirname(libparametric_path))

    global libexcept_path = normpath(joinpath(artifact_dir, libexcept_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libexcept_handle = dlopen(libexcept_path)
    push!(LIBPATH_list, dirname(libexcept_path))

    # Filter out duplicate and empty entries in our PATH and LIBPATH entries
    filter!(!isempty, unique!(PATH_list))
    filter!(!isempty, unique!(LIBPATH_list))
    global PATH = join(PATH_list, ';')
    global LIBPATH = join(LIBPATH_list, ';')

    # Add each element of LIBPATH to our DL_LOAD_PATH (necessary on platforms
    # that don't honor our "already opened" trick)
    #for lp in LIBPATH_list
    #    push!(DL_LOAD_PATH, lp)
    #end
end  # __init__()

